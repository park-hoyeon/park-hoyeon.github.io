---
layout: category
title: "백준 2468번 안전 영역"
permalink: /Study/algorithm/silver/2468
author_profile: true
sidebar_main: true
types: posts
sidebar:
  nav: "sidebar-category"
  enabled: true
categories:
  - Blog
tags:
  - 2024-python-coding-study
  - Python
  - Coding
---

## [안전 영역 문제 바로 가기](https://www.acmicpc.net/problem/2468)

<div style="border: 1px solid rgba(255, 255, 255, 0.2); padding: 15px; border-radius: 5px; background-color: rgba(255, 255, 255, 0.05); color: #f1f1f1; text-align: left;">

<b>문제:</b><br>
어떤 지역의 높이 정보가 주어졌을 때, 비가 왔을 때 물에 잠기지 않는 안전한 영역의 최대 개수를 구하는 문제.<br>
비의 높이는 문제에 주어지지 않기 때문에, 가능한 모든 비의 높이에 대해 시뮬레이션해야 함.<br><br>

<b>입력:</b><br>
첫째 줄에 지역의 크기 N이 주어진다. (1 ≤ N ≤ 100)<br>
둘째 줄부터 N개의 줄에 각 지점의 높이 정보가 주어진다. (1 ≤ 높이 ≤ 100)<br><br>

<b>출력:</b><br>
비의 높이를 조절했을 때, 물에 잠기지 않는 영역(연결된 구역)의 최대 개수를 출력한다.<br>

</div>

<br>

<span style="color:yellow">풀이 코드</span>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/atom-one-dark.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
<script>hljs.highlightAll();</script>

<div style="padding: 8px; border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 5px; background-color: rgba(255, 255, 255, 0.05); color: #f1f1f1; width: 100%; text-align: left; font-family: monospace;">
<pre><code class="python">
from collections import deque

dx = [0,0,-1,1]
dy = [-1,1,0,0]

def bfs(x,y,h):
    q = deque()
    q.append((x,y))
    visited[y][x] = True

    while q:
        x, y = q.popleft()
        for i in range(4):
            nx = dx[i] + x
            ny = dy[i] + y

            if 0 <= nx < n and 0 <= ny < n:
                if not visited[ny][nx] and graph[ny][nx] > h:
                    visited[ny][nx] = True
                    q.append((nx, ny))

n = int(input())
graph = [list(map(int, input().split())) for _ in range(n)]
max_len = max(map(max, graph))
result = 0

for h in range(0, max_len+1):
    count = 0
    visited = [[False] * n for _ in range(n)]
    for y in range(n):
        for x in range(n):
            if graph[y][x] > h and not visited[y][x]:
                bfs(x, y, h)
                count += 1
    result = max(result, count)

print(result)
</code></pre>
</div>

<br>

<span style="color:yellow">해결 방법:</span><br>

- 입력으로 주어진 높이 정보 중 최대 높이를 구해 그 높이까지 모든 비의 높이에 대해 시뮬레이션 진행.
- 물에 잠기지 않는 지점(`graph[y][x] > h`)을 기준으로 BFS로 연결된 영역을 탐색함.
- `visited` 배열은 각 높이별로 새로 초기화해야 함.
- 실수했던 부분은 다음과 같음:
  - `visited`와 `count`를 반복문 밖에 두어서 값이 누적되거나 이전 상태가 남음
  - 비 높이를 `n`과 비교해서 문제의 의미와 다른 방식으로 처리함 (→ `graph[y][x] > h` 가 맞음)
- 높이마다 BFS 돌리고 영역 개수 세어 `result = max(result, count)`로 최대 안전 영역 수 갱신.

---

<div style="text-align: right; margin-top: 30px;">
  <button onclick="scrollToTop()" style="
    padding: 10px 15px; 
    background-color: #FFEB46; 
    color: black; 
    border: 2px solid #FFEB46; 
    border-radius: 5px; 
    cursor: pointer; 
    font-size: 10px;">
    맨 위로 이동
  </button>
</div>

<script>
  function scrollToTop() {
    window.scrollTo({ top: 0, behavior: 'smooth' });
  }
</script>
