---
layout: category
title: "백준 1743번 - 음식물 피하기"
permalink: /Study/algorithm/silver/1743
author_profile: true
sidebar_main: true
types: posts
sidebar:
  nav: "sidebar-category"
  enabled: true
categories:
  - Blog
tags:
  - 2025-python-coding-study
  - Python
  - Coding
---

## [음식물 피하기 문제 바로 가기](https://www.acmicpc.net/problem/1743)

##### baekjoon 알고리즘 문제 풀이

<div style="border: 1px solid rgba(255, 255, 255, 0.2); padding: 15px; border-radius: 5px; background-color: rgba(255, 255, 255, 0.05); color: #f1f1f1; width: 100%; margin-left: 0; margin-right: 0; text-align: left;">
<b>문제:</b><br>
코레스코 콘도미니엄 8층은 학생들이 3끼의 식사를 해결하는 공간이다. 그러나 몇몇 비양심적인 학생들의 만행으로 음식물이 통로 중간 중간에 떨어져 있다. 이러한 음식물들은 근처에 있는 것끼리 뭉치게 돼서 큰 음식물 쓰레기가 된다. 

이 문제를 출제한 선생님은 개인적으로 이러한 음식물을 실내화에 묻히는 것을 정말 진정으로 싫어한다. 참고로 우리가 구해야 할 답은 이 문제를 낸 조교를 맞추는 것이 아니다. 

통로에 떨어진 음식물을 피해가기란 쉬운 일이 아니다. 따라서 선생님은 떨어진 음식물 중에 제일 큰 음식물만은 피해 가려고 한다. 

선생님을 도와 제일 큰 음식물의 크기를 구해서 “10ra"를 외치지 않게 도와주자..

<br/>

<span style="color:yellow">입력</span><br/>
첫째 줄에 통로의 세로 길이 N(1 ≤ N ≤ 100)과 가로 길이 M(1 ≤ M ≤ 100) 그리고 음식물 쓰레기의 개수 K(1 ≤ K ≤ N×M)이 주어진다.  그리고 다음 K개의 줄에 음식물이 떨어진 좌표 (r, c)가 주어진다.

좌표 (r, c)의 r은 위에서부터, c는 왼쪽에서부터가 기준이다. 입력으로 주어지는 좌표는 중복되지 않는다.

<br/>

<span style="color:yellow">출력</span><br/>
첫째 줄에 음식물 중 가장 큰 음식물의 크기를 출력하라
</div>

<span style="color:yellow">풀이 코드</span>  
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/atom-one-dark.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
<script>hljs.highlightAll();</script>
<div style="padding:8px; border: 1px solid rgba(255, 255, 255, 0.2); border-radius:5px; background-color: rgba(255, 255, 255, 0.05); color: #f1f1f1; width: 100%; margin-left: 0; margin-right: 0; text-align: left; font-family: monospace;">
  <pre><code class="python">
from collections import deque

dx = [0,0,-1,1]
dy = [-1,1,0,0]

n,m,k = map(int, input().split())
visited = [[False]*m for _ in range(n)]
graph = [[0]*m for _ in range(n)]
for _ in range(k):
    r,c = map(int, input().split())
    graph[r-1][c-1] = 1

def bfs(x,y):
    q = deque()
    q.append((x,y))
    visited[y][x] = True
    count = 1

    while q:
        x,y = q.popleft()
        for i in range(4):
            nx = dx[i]+x
            ny = dy[i]+y

            if 0<=nx<m and 0<=ny<n and not visited[ny][nx] and graph[ny][nx] == 1:
                count +=1
                visited[ny][nx] = True
                q.append((nx,ny))
    return count

answer = 0
for y in range(n):
    for x in range(m):
        if graph[y][x] == 1 and not visited[y][x]:
            answer = max(answer, bfs(x,y))
print(answer)


  </code></pre>
</div>

<span style="color:yellow">해결 전략:</span><br/>

- W랑 B 각각 BFS 돌려서 독립된 군대 단위로 탐색한다.
- 같은 알파벳 병사들끼리만 상하좌우 연결되도록 조건을 건다.
- 군대 단위로 모인 병사 수를 세고, 그 수를 제곱해서 전투력으로 계산한다.
- 이렇게 나온 전투력을 W, B 따로 누적한 다음 마지막에 합산해서 출력한다.

---

<div style="text-align: right; margin-top: 30px;">
  <button onclick="scrollToTop()" style="
    padding: 10px 15px; 
    background-color: #FFEB46; 
    color: black; 
    border: 2px solid #FFEB46; 
    border-radius: 5px; 
    cursor: pointer; 
    font-size: 10px;">
    맨 위로 이동
  </button>
</div>

<script>
  function scrollToTop() {
    window.scrollTo({ top: 0, behavior: 'smooth' });
  }
</script>
