---
layout: category
title: "백준 3184번 양"
permalink: /Study/algorithm/silver/3184
author_profile: true
sidebar_main: true
types: posts
sidebar:
  nav: "sidebar-category"
  enabled: true
categories:
  - Blog
tags:
  - 2025-python-coding-study
  - Python
  - Coding
---

## [양 문제 바로 가기](https://www.acmicpc.net/problem/3184)

<div style="border: 1px solid rgba(255, 255, 255, 0.2); padding: 15px; border-radius: 5px; background-color: rgba(255, 255, 255, 0.05); color: #f1f1f1; text-align: left;">

<b>문제:</b><br>
미키의 뒷마당에는 특정 수의 양이 있다. 그가 푹 잠든 사이에 배고픈 늑대는 마당에 들어와 양을 공격했다.

마당은 행과 열로 이루어진 직사각형 모양이다. 글자 '.' (점)은 빈 필드를 의미하며, 글자 '#'는 울타리를, 'o'는 양, 'v'는 늑대를 의미한다.

한 칸에서 수평, 수직만으로 이동하며 울타리를 지나지 않고 다른 칸으로 이동할 수 있다면, 두 칸은 같은 영역 안에 속해 있다고 한다. 마당에서 "탈출"할 수 있는 칸은 어떤 영역에도 속하지 않는다고 간주한다.

다행히 우리의 양은 늑대에게 싸움을 걸 수 있고 영역 안의 양의 수가 늑대의 수보다 많다면 이기고, 늑대를 우리에서 쫓아낸다. 그렇지 않다면 늑대가 그 지역 안의 모든 양을 먹는다.

맨 처음 모든 양과 늑대는 마당 안 영역에 존재한다.

아침이 도달했을 때 살아남은 양과 늑대의 수를 출력하는 프로그램을 작성하라.

<br><br>

<b>입력:</b><br>
첫 줄에는 두 정수 R과 C가 주어지며(3 ≤ R, C ≤ 250), 각 수는 마당의 행과 열의 수를 의미한다.

다음 R개의 줄은 C개의 글자를 가진다. 이들은 마당의 구조(울타리, 양, 늑대의 위치)를 의미한다.

<br><br>

<b>출력:</b><br>
- 하나의 줄에 아침까지 살아있는 양과 늑대의 수를 의미하는 두 정수를 출력한다
</div>

<br>

<span style="color:yellow">풀이 코드</span>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/atom-one-dark.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
<script>hljs.highlightAll();</script>

<div style="padding: 8px; border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 5px; background-color: rgba(255, 255, 255, 0.05); color: #f1f1f1; text-align: left; font-family: monospace;">
<pre><code class="python">
import sys
from collections import deque

dx = [0,0,-1,1]
dy = [-1,1,0,0]

r,c = map(int, input().split())
graph = []
visited = [[False]*c for _ in range(r)]
for _ in range(r):
    graph.append(list(sys.stdin.readline().strip()))

def bfs(x,y):
    q = deque()
    q.append((x,y))
    visited[y][x] = True

    sheep = 0
    wolf = 0

    if graph[y][x] == 'o':
        sheep += 1
    if graph[y][x] == 'v':
        wolf += 1

    while q:
        x,y = q.popleft()
        for i in range(4):
            nx = dx[i]+x
            ny = dy[i]+y
            if 0<= nx < c and 0<= ny < r and not visited[ny][nx] and graph[ny][nx] != '#':
                visited[ny][nx] = True
                if graph[ny][nx] == 'o':
                    sheep+=1
                elif graph[ny][nx] == 'v':
                    wolf+=1
                q.append((nx,ny))
    return sheep, wolf

total_sheep = 0
total_wolf = 0

for y in range(r):
    for x in range(c):
        if graph[y][x] != '#' and not visited[y][x]:
            s,w = bfs(x,y)
            if s > w:
                total_sheep+=s
            else:
                total_wolf+=w
print(total_sheep, total_wolf)
</code></pre>
</div>

<br>

<span style="color:yellow">해결 방법:</span><br>

- 시작 좌표에서 BFS를 시작하며, 해당 칸이 양(o)이나 늑대(v)라면 먼저 개수를 센다.

- BFS로 연결된 영역을 탐색하며, 새로운 칸을 방문할 때마다 o와 v를 각각 집계한다.

- 영역 탐색이 끝나면 양 수와 늑대 수를 비교하여 더 많은 쪽만 전체 결과에 더한다.


<br>

<div style="text-align: right; margin-top: 30px;">
  <button onclick="scrollToTop()" style="
    padding: 10px 15px; 
    background-color: #FFEB46; 
    color: black; 
    border: 2px solid #FFEB46; 
    border-radius: 5px; 
    cursor: pointer; 
    font-size: 10px;">
    맨 위로 이동
  </button>
</div>

<script>
  function scrollToTop() {
    window.scrollTo({ top: 0, behavior: 'smooth' });
  }
</script>
